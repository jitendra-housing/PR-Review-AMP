/**
 * Format review findings as GitHub markdown
 */

/**
 * Format individual finding
 * @param {Object} finding - Finding object with file, line, severity, message
 * @returns {string} Formatted markdown
 */
function formatFinding(finding) {
  const { file, line, severity, category, message } = finding;
  const icon = severity === 'HIGH' ? 'ðŸ”´' : severity === 'MEDIUM' ? 'ðŸŸ¡' : 'ðŸŸ¢';
  const location = line ? `${file}:${line}` : file;

  let output = `${icon} **${severity}**`;
  if (category) output += ` - ${category}`;
  output += `\n\n**File:** \`${location}\`\n\n${message}\n`;

  return output;
}

/**
 * Format complete review as markdown
 * @param {Array} findings - Array of finding objects
 * @param {Object} stats - Review statistics
 * @param {Object} prData - PR metadata
 * @returns {string} Complete markdown review
 */
function formatReview(findings, stats, prData) {
  const sections = [];

  // Header
  sections.push('# Code Review\n');
  sections.push(`**PR:** #${prData.number} - ${prData.title}\n`);
  sections.push(`**Files Changed:** ${stats.filesReviewed} reviewed, ${stats.filesSkipped} skipped\n`);
  sections.push(`**Lines Changed:** +${stats.additions} -${stats.deletions}\n`);
  sections.push('---\n');

  // Overall assessment
  if (findings.length === 0) {
    sections.push('## âœ… No Issues Found\n');
    sections.push('The code looks good! No significant issues were identified during the review.\n');
  } else {
    sections.push('## ðŸ“‹ Summary\n');
    const highCount = findings.filter(f => f.severity === 'HIGH').length;
    const mediumCount = findings.filter(f => f.severity === 'MEDIUM').length;
    const lowCount = findings.filter(f => f.severity === 'LOW').length;

    sections.push(`- ðŸ”´ **High Priority:** ${highCount}\n`);
    sections.push(`- ðŸŸ¡ **Medium Priority:** ${mediumCount}\n`);
    sections.push(`- ðŸŸ¢ **Low Priority / Suggestions:** ${lowCount}\n`);
    sections.push('\n---\n');

    // Group findings by severity
    const bySeverity = {
      HIGH: findings.filter(f => f.severity === 'HIGH'),
      MEDIUM: findings.filter(f => f.severity === 'MEDIUM'),
      LOW: findings.filter(f => f.severity === 'LOW')
    };

    // High priority issues
    if (bySeverity.HIGH.length > 0) {
      sections.push('## ðŸ”´ High Priority Issues\n');
      sections.push('These issues should be addressed before merging.\n\n');
      bySeverity.HIGH.forEach((finding, idx) => {
        sections.push(`### ${idx + 1}. ${finding.category || 'Issue'}\n`);
        sections.push(formatFinding(finding));
        sections.push('\n');
      });
      sections.push('---\n');
    }

    // Medium priority issues
    if (bySeverity.MEDIUM.length > 0) {
      sections.push('## ðŸŸ¡ Medium Priority Issues\n');
      sections.push('These issues should be reviewed and considered.\n\n');
      bySeverity.MEDIUM.forEach((finding, idx) => {
        sections.push(`### ${idx + 1}. ${finding.category || 'Issue'}\n`);
        sections.push(formatFinding(finding));
        sections.push('\n');
      });
      sections.push('---\n');
    }

    // Low priority / Suggestions
    if (bySeverity.LOW.length > 0) {
      sections.push('## ðŸŸ¢ Suggestions & Best Practices\n');
      sections.push('Optional improvements for code quality.\n\n');
      bySeverity.LOW.forEach((finding, idx) => {
        sections.push(`### ${idx + 1}. ${finding.category || 'Suggestion'}\n`);
        sections.push(formatFinding(finding));
        sections.push('\n');
      });
    }
  }

  // Footer
  sections.push('\n---\n');
  sections.push('*ðŸ¤– Generated by Claude Code Review*\n');

  return sections.join('');
}

/**
 * Parse findings from Claude's response
 * @param {string} text - Claude's response text
 * @returns {Array} Array of finding objects
 */
function parseFindings(text) {
  const findings = [];

  // Primary parser: Look for structured findings in the format:
  // FILE: path/to/file.js:123
  // SEVERITY: HIGH|MEDIUM|LOW
  // CATEGORY: Category Name
  // MESSAGE: Description...

  const findingPattern = /FILE:\s*(.+?)(?::(\d+))?\s*\nSEVERITY:\s*(HIGH|MEDIUM|LOW)\s*\n(?:CATEGORY:\s*(.+?)\s*\n)?MESSAGE:\s*([\s\S]+?)(?=\n\n(?:FILE:|$)|$)/gi;

  let match;
  while ((match = findingPattern.exec(text)) !== null) {
    const message = match[5].trim();

    // Skip empty messages or messages that are just the severity repeated
    if (message && message.length > 10 && !message.match(/^(HIGH|MEDIUM|LOW|SEVERITY:)/i)) {
      findings.push({
        file: match[1].trim(),
        line: match[2] ? parseInt(match[2]) : null,
        severity: match[3],
        category: match[4] ? match[4].trim() : null,
        message: message
      });
    }
  }

  console.log(`[PARSE] Structured format found ${findings.length} findings`);

  // Fallback parser: Try to extract from narrative/markdown format
  if (findings.length === 0) {
    console.log('[PARSE] No structured findings, attempting fallback parsing...');

    // Try to find sections by severity
    const sections = text.split(/(?=#{1,3}\s+(?:HIGH|MEDIUM|LOW|Critical|Important|Suggestions))/i);

    for (const section of sections) {
      // Detect severity from section header
      let severity = 'MEDIUM';
      if (section.match(/HIGH|Critical|ðŸ”´/i)) severity = 'HIGH';
      if (section.match(/MEDIUM|Important|ðŸŸ¡/i)) severity = 'MEDIUM';
      if (section.match(/LOW|Suggestion|ðŸŸ¢/i)) severity = 'LOW';

      // Extract findings from bullets or numbered lists
      const lines = section.split('\n');
      let currentFinding = null;
      let currentFile = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Detect file references (multiple formats)
        const filePatterns = [
          /(?:File|Path|Location):\s*`?([^`\n]+\.(swift|kt|java|js|ts|tsx|jsx|py|rb|go|rs|php|m|mm|dart|vue|svelte)(?::\d+)?)`?/i,
          /`([^`]+\.(swift|kt|java|js|ts|tsx|jsx|py|rb|go|rs|php|m|mm|dart|vue|svelte)(?::\d+)?)`/,
          /\*\*([^*]+\.(swift|kt|java|js|ts|tsx|jsx|py|rb|go|rs|php|m|mm|dart|vue|svelte)(?::\d+)?)\*\*/
        ];

        for (const pattern of filePatterns) {
          const fileMatch = line.match(pattern);
          if (fileMatch) {
            currentFile = fileMatch[1];
            break;
          }
        }

        // Detect numbered or bulleted items with actual content
        const itemMatch = line.match(/^(?:\d+\.|[-*â€¢])\s+(.+)/);
        if (itemMatch && itemMatch[1].length > 15) {
          const content = itemMatch[1];

          // Skip if it's just a severity label
          if (!content.match(/^(HIGH|MEDIUM|LOW|SEVERITY|Issue|Category)$/i)) {
            // Look ahead for multiline content
            let message = content;
            for (let j = i + 1; j < lines.length && j < i + 5; j++) {
              const nextLine = lines[j].trim();
              if (!nextLine || nextLine.match(/^(?:\d+\.|[-*â€¢]|#{1,3})/)) break;
              message += ' ' + nextLine;
            }

            if (message.length > 20) {
              findings.push({
                file: currentFile || 'Multiple files',
                line: null,
                severity: severity,
                category: null,
                message: message.replace(/[ðŸ”´ðŸŸ¡ðŸŸ¢]/g, '').trim()
              });
            }
          }
        }
      }
    }

    console.log(`[PARSE] Fallback parser found ${findings.length} findings`);
  }

  // Last resort: If still no findings, check if Claude said "no issues"
  if (findings.length === 0) {
    if (text.match(/no\s+(issues?|problems?|concerns?)\s+found/i)) {
      console.log('[PARSE] No issues found in response');
      return [];
    }

    console.warn('[PARSE] âš  Failed to parse any findings from response');
    console.warn('[PARSE] Response preview:', text.substring(0, 500));
  }

  return findings;
}

module.exports = { formatReview, formatFinding, parseFindings };
